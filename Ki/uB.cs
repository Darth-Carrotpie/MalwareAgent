// Decompiled with JetBrains decompiler
// Type: Ki.uB
// Assembly: service-nankasa.com-LoggerBin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 762D1AAC-A39C-4AEB-81B7-3308162A414F
// Assembly location: C:\Users\darbinis\Desktop\Code analysis\Mallicious skriptai\Atack 09-17\RegAsm.exe

using oCN;
using System;
using System.Runtime.InteropServices;

namespace Ki
{
  internal static class uB
  {
    public const uint ERROR_SUCCESS = 0;
    public const uint BCRYPT_PAD_PSS = 8;
    public const uint BCRYPT_PAD_OAEP = 4;
    public static readonly byte[] BCRYPT_KEY_DATA_BLOB_MAGIC;
    public static readonly string BCRYPT_OBJECT_LENGTH;
    public static readonly string BCRYPT_CHAIN_MODE_GCM;
    public static readonly string BCRYPT_AUTH_TAG_LENGTH;
    public static readonly string BCRYPT_CHAINING_MODE;
    public static readonly string BCRYPT_KEY_DATA_BLOB;
    public static readonly string BCRYPT_AES_ALGORITHM;
    public static readonly string MS_PRIMITIVE_PROVIDER;
    public static readonly int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG;
    public static readonly int BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
    public static readonly uint STATUS_AUTH_TAG_MISMATCH;
    private static uB lHW;

    [DllImport("bcrypt.dll", EntryPoint = "BCryptOpenAlgorithmProvider")]
    public static extern uint CWT(
      out IntPtr _param0,
      [MarshalAs(UnmanagedType.LPWStr)] string _param1,
      [MarshalAs(UnmanagedType.LPWStr)] string _param2,
      uint _param3);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptCloseAlgorithmProvider")]
    public static extern uint hWw(IntPtr _param0, uint _param1);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptGetProperty")]
    public static extern uint EWh(
      IntPtr _param0,
      [MarshalAs(UnmanagedType.LPWStr)] string _param1,
      byte[] _param2,
      int _param3,
      ref int _param4,
      uint _param5);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptSetProperty")]
    internal static extern uint dWH(
      IntPtr _param0,
      [MarshalAs(UnmanagedType.LPWStr)] string _param1,
      byte[] _param2,
      int _param3,
      int _param4);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptImportKey")]
    public static extern uint nWx(
      IntPtr _param0,
      IntPtr _param1,
      [MarshalAs(UnmanagedType.LPWStr)] string _param2,
      out IntPtr _param3,
      IntPtr _param4,
      int _param5,
      byte[] _param6,
      int _param7,
      uint _param8);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptDestroyKey")]
    public static extern uint TWo(IntPtr _param0);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptEncrypt")]
    public static extern uint zWe(
      IntPtr _param0,
      byte[] _param1,
      int _param2,
      ref uB.nr _param3,
      byte[] _param4,
      int _param5,
      byte[] _param6,
      int _param7,
      ref int _param8,
      uint _param9);

    [DllImport("bcrypt.dll", EntryPoint = "BCryptDecrypt")]
    internal static extern uint BWF(
      IntPtr _param0,
      byte[] _param1,
      int _param2,
      ref uB.nr _param3,
      byte[] _param4,
      int _param5,
      byte[] _param6,
      int _param7,
      ref int _param8,
      int _param9);

    static uB()
    {
      yd.bx(yd.EI);
      uB.BCRYPT_KEY_DATA_BLOB_MAGIC = BitConverter.GetBytes(1296188491);
      uB.BCRYPT_OBJECT_LENGTH = w4.bx(6906, w4.vY);
      uB.BCRYPT_CHAIN_MODE_GCM = w4.bx(6934, w4.vY);
      int num1 = 0;
      if (false)
        goto label_3;
label_1:
      switch (num1)
      {
        default:
          uB.BCRYPT_AUTH_TAG_LENGTH = w4.bx(6968, w4.vY);
          uB.BCRYPT_CHAINING_MODE = w4.bx(6998, w4.vY);
          uB.BCRYPT_KEY_DATA_BLOB = w4.bx(7026, w4.vY);
          uB.BCRYPT_AES_ALGORITHM = w4.bx(7052, w4.vY);
          uB.MS_PRIMITIVE_PROVIDER = w4.bx(7062, w4.vY);
          uB.BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 1;
          uB.BCRYPT_INIT_AUTH_MODE_INFO_VERSION = 1;
          uB.STATUS_AUTH_TAG_MISMATCH = 3221266434U;
          return;
      }
label_3:
      int num2;
      num1 = num2;
      goto label_1;
    }

    internal static bool kHz() => uB.lHW == null;

    internal static uB eTB() => uB.lHW;

    internal struct yu
    {
      [MarshalAs(UnmanagedType.LPWStr)]
      public string pszAlgId;
      public int cbSalt;
      private static object NTH;

      public yu(string _param1, int _param2)
      {
        yd.bx(yd.EI);
        this.pszAlgId = _param1;
        this.cbSalt = _param2;
      }

      internal static bool HTT() => uB.yu.NTH == null;

      internal static object HTl() => uB.yu.NTH;
    }

    internal struct nr : IDisposable
    {
      public int cbSize;
      public int dwInfoVersion;
      public IntPtr pbNonce;
      public int cbNonce;
      public IntPtr pbAuthData;
      public int cbAuthData;
      public IntPtr pbTag;
      public int cbTag;
      public IntPtr pbMacContext;
      public int cbMacContext;
      public int cbAAD;
      public long cbData;
      public int dwFlags;
      internal static object UTa;

      public unsafe nr(byte[] _param1, byte[] _param2, byte[] _param3)
      {
        yd.bx(yd.EI);
        *(uB.nr*) ref this = new uB.nr();
        int num1 = 0;
        if (true)
          goto label_2;
label_1:
        int num2;
        num1 = num2;
label_2:
        while (true)
        {
          switch (num1)
          {
            case 1:
              goto label_10;
            default:
              this.dwInfoVersion = uB.BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
              this.cbSize = Marshal.SizeOf(Type.GetTypeFromHandle(lC0.q8qryK(33554464)));
              if (_param1 != null)
              {
                this.cbNonce = _param1.Length;
                this.pbNonce = uB.nr.dTA(this.cbNonce);
                Marshal.Copy(_param1, 0, this.pbNonce, this.cbNonce);
              }
              if (_param2 != null)
                goto label_11;
label_7:
              if (_param3 != null)
              {
                this.cbTag = _param3.Length;
                this.pbTag = Marshal.AllocHGlobal(this.cbTag);
                Marshal.Copy(_param3, 0, this.pbTag, this.cbTag);
                if (true)
                {
                  num1 = 1;
                  continue;
                }
                goto label_1;
              }
              else
                goto label_8;
label_11:
              this.cbAuthData = _param2.Length;
              this.pbAuthData = Marshal.AllocHGlobal(this.cbAuthData);
              Marshal.Copy(_param2, 0, this.pbAuthData, this.cbAuthData);
              goto label_7;
          }
        }
label_8:
        return;
label_10:
        this.cbMacContext = _param3.Length;
        this.pbMacContext = Marshal.AllocHGlobal(this.cbMacContext);
      }

      public void Dispose()
      {
        if (this.pbNonce != IntPtr.Zero)
          Marshal.FreeHGlobal(this.pbNonce);
        if (uB.nr.QT4(this.pbTag, IntPtr.Zero))
          goto label_4;
label_3:
        if (this.pbAuthData != IntPtr.Zero)
          goto label_6;
label_5:
        if (!(this.pbMacContext != IntPtr.Zero))
          return;
        Marshal.FreeHGlobal(this.pbMacContext);
        return;
label_6:
        Marshal.FreeHGlobal(this.pbAuthData);
        goto label_5;
label_4:
        Marshal.FreeHGlobal(this.pbTag);
        goto label_3;
      }

      internal static IntPtr dTA([In] int obj0) => Marshal.AllocHGlobal(obj0);

      internal static bool kTd() => uB.nr.UTa == null;

      internal static object OTG() => uB.nr.UTa;

      internal static bool QT4([In] IntPtr obj0, [In] IntPtr obj1) => obj0 != obj1;
    }

    internal struct i1
    {
      public int dwMinLength;
      public int dwMaxLength;
      public int dwIncrement;
    }

    internal struct j3
    {
      [MarshalAs(UnmanagedType.LPWStr)]
      public string pszAlgId;
      public IntPtr pbLabel;
      public int cbLabel;
      private static object mT6;

      public j3(string _param1)
      {
        yd.bx(yd.EI);
        this.pszAlgId = _param1;
        this.pbLabel = IntPtr.Zero;
        this.cbLabel = 0;
      }

      internal static bool RTP() => uB.j3.mT6 == null;

      internal static object ITt() => uB.j3.mT6;
    }
  }
}
